import io
from unittest.mock import MagicMock, patch

from fastapi.testclient import TestClient


def _upload_photo(client: TestClient, gallery_id: str, content: bytes, filename: str = "photo.jpg") -> str:
    files = {"file": (filename, io.BytesIO(content), "image/jpeg")}
    resp = client.post(f"/galleries/{gallery_id}/photos", files=files)
    assert resp.status_code == 201
    return resp.json()["id"]


class TestPublicAPI:
    def test_get_photos_by_sharelink_and_urls(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Upload two photos
        _p1 = _upload_photo(authenticated_client, gallery_id_fixture, b"one", "a.jpg")
        _p2 = _upload_photo(authenticated_client, gallery_id_fixture, b"two", "b.jpg")

        # Create sharelink for gallery
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        assert resp.status_code == 201
        share_id = resp.json()["id"]

        # Public gallery listing
        public_resp = authenticated_client.get(f"/s/{share_id}")
        assert public_resp.status_code == 200
        data = public_resp.json()
        assert "photos" in data
        assert isinstance(data["photos"], list)
        # filenames should be present
        names = [p["filename"] for p in data["photos"]]
        assert any("a.jpg" in n or "b.jpg" in n for n in names)

        # Get all photo urls - the app will generate real presigned URLs in tests
        urls_resp = authenticated_client.get(f"/s/{share_id}/photos/urls")
        assert urls_resp.status_code == 200
        url_list = urls_resp.json()
        assert isinstance(url_list, list)
        assert len(url_list) == 2
        for item in url_list:
            assert isinstance(item.get("thumbnail_url"), str)
            assert item["thumbnail_url"].startswith("http")
            # presigned urls generated by boto3 include X-Amz-Algorithm or X-Amz-Signature
            assert ("X-Amz-Algorithm" in item["thumbnail_url"] or "X-Amz-Signature" in item["thumbnail_url"]) or item["thumbnail_url"].startswith("http://localhost")

    def test_get_single_photo_presigned_url_and_not_found(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Upload a photo and create sharelink
        photo_id = _upload_photo(authenticated_client, gallery_id_fixture, b"imgdata", "one.jpg")
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        share_id = resp.json()["id"]

        r = authenticated_client.get(f"/s/{share_id}/photos/{photo_id}/url")
        assert r.status_code == 200
        url = r.json()["url"]
        assert isinstance(url, str)
        assert url.startswith("http")
        assert ("X-Amz-Algorithm" in url or "X-Amz-Signature" in url) or url.startswith("http://localhost")

        fake = "00000000-0000-0000-0000-000000000000"
        r2 = authenticated_client.get(f"/s/{share_id}/photos/{fake}/url")
        assert r2.status_code == 404

    def test_stream_photo_and_downloads(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Upload photo and create sharelink
        content = b"streamcontent"
        photo_id = _upload_photo(authenticated_client, gallery_id_fixture, content, "stream.jpg")
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        share_id = resp.json()["id"]

        # Mock minio config and s3 client get_object to return a file-like body
        fake_bucket = "test-bucket"
        fake_obj = {"Body": io.BytesIO(content), "ContentType": "image/jpeg"}

        with patch("src.viewport.api.public.get_minio_config", return_value=(None, None, None, fake_bucket)), patch("src.viewport.api.public.get_s3_client") as mock_get_s3:
            mock_client = MagicMock()
            mock_client.get_object.return_value = fake_obj
            mock_get_s3.return_value = mock_client

            # Stream photo
            stream_resp = authenticated_client.get(f"/s/{share_id}/photos/{photo_id}")
            assert stream_resp.status_code == 200
            # content should match
            assert stream_resp.content == content
            # headers should include caching
            assert "Cache-Control" in stream_resp.headers

            # Download single
            dl_resp = authenticated_client.get(f"/s/{share_id}/download/{photo_id}")
            assert dl_resp.status_code == 200
            assert dl_resp.content == content
            assert dl_resp.headers.get("Content-Disposition", "").startswith("attachment;")

            # Download all as zip
            dl_all = authenticated_client.get(f"/s/{share_id}/download/all")
            assert dl_all.status_code == 200
            assert dl_all.headers.get("Content-Type") == "application/zip"

    def test_download_all_404_when_no_photos(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Create sharelink for empty gallery
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        share_id = resp.json()["id"]

        # Remove photos from gallery by attempting download on a new empty gallery
        r = authenticated_client.get(f"/s/{share_id}/download/all")
        # Should be 404 because no photos
        assert r.status_code == 404
