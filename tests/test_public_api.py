import io
from typing import cast
from unittest.mock import MagicMock, patch

from fastapi.testclient import TestClient


def _upload_photo(client: TestClient, gallery_id: str, content: bytes, filename: str = "photo.jpg") -> str:
    files = {"files": (filename, io.BytesIO(content), "image/jpeg")}
    resp = client.post(f"/galleries/{gallery_id}/photos/batch", files=files)
    assert resp.status_code == 200
    data = resp.json()
    assert data["successful_uploads"] == 1
    return cast(str, data["results"][0]["photo"]["id"])


class TestPublicAPI:
    def test_get_photos_by_sharelink_and_urls(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Upload two photos
        _p1 = _upload_photo(authenticated_client, gallery_id_fixture, b"one", "a.jpg")
        _p2 = _upload_photo(authenticated_client, gallery_id_fixture, b"two", "b.jpg")

        # Create sharelink for gallery
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        assert resp.status_code == 201
        share_id = resp.json()["id"]

        # Public gallery listing - now includes presigned URLs directly
        public_resp = authenticated_client.get(f"/s/{share_id}")
        assert public_resp.status_code == 200
        data = public_resp.json()
        assert "photos" in data
        assert isinstance(data["photos"], list)
        assert len(data["photos"]) == 2

        # Check filenames are present
        names = [p["filename"] for p in data["photos"]]
        assert any("a.jpg" in n or "b.jpg" in n for n in names)

        # Check that presigned URLs are included in the response
        for photo in data["photos"]:
            assert "full_url" in photo
            assert "thumbnail_url" in photo
            assert isinstance(photo["full_url"], str)
            assert isinstance(photo["thumbnail_url"], str)
            assert photo["full_url"].startswith("http")
            assert photo["thumbnail_url"].startswith("http")
            # presigned urls generated by boto3 include X-Amz-Algorithm or X-Amz-Signature
            assert ("X-Amz-Algorithm" in photo["full_url"] or "X-Amz-Signature" in photo["full_url"]) or photo["full_url"].startswith("http://localhost")
            assert ("X-Amz-Algorithm" in photo["thumbnail_url"] or "X-Amz-Signature" in photo["thumbnail_url"]) or photo["thumbnail_url"].startswith("http://localhost")

    def test_stream_photo_and_downloads(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Upload photo and create sharelink
        content = b"streamcontent"
        _photo_id = _upload_photo(authenticated_client, gallery_id_fixture, content, "stream.jpg")
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        share_id = resp.json()["id"]

        # Mock minio config and s3 client get_object to return a file-like body
        fake_bucket = "test-bucket"
        fake_obj = {"Body": io.BytesIO(content), "ContentType": "image/jpeg"}

        with patch("viewport.api.public.get_minio_config", return_value=(None, None, None, fake_bucket, 'lol', 'kek')), patch("viewport.api.public.get_s3_client") as mock_get_s3:
            mock_client = MagicMock()
            mock_client.get_object.return_value = fake_obj
            mock_get_s3.return_value = mock_client

            # Download all as zip
            dl_all = authenticated_client.get(f"/s/{share_id}/download/all")
            assert dl_all.status_code == 200
            assert dl_all.headers.get("Content-Type") == "application/zip"

    def test_download_all_404_when_no_photos(self, authenticated_client: TestClient, gallery_id_fixture: str):
        # Create sharelink for empty gallery
        resp = authenticated_client.post(f"/galleries/{gallery_id_fixture}/share-links", json={"gallery_id": gallery_id_fixture, "expires_at": "2099-01-01T00:00:00Z"})
        share_id = resp.json()["id"]

        # Remove photos from gallery by attempting download on a new empty gallery
        r = authenticated_client.get(f"/s/{share_id}/download/all")
        # Should be 404 because no photos
        assert r.status_code == 404
