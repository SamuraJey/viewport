# План: Рефакторинг архитектуры Confirmation Modal

Текущая реализация в `GalleryPage.tsx` использует единый обработчик `handleConfirmAction` с цепочкой `if/else` по типу действия. Это нарушает принципы SRP и OCP, создаёт сильную связность UI и бизнес-логики, затрудняет тестирование и масштабирование.

---

## 1. Цели изменений

- **Устранить switch/if-chain** — бизнес-логика каждого действия должна быть изолирована
- **Повысить типобезопасность** — избавиться от `data?: unknown` и ручных type-casts
- **Упростить добавление новых действий** — одно место для регистрации, без изменения core-логики
- **Улучшить тестируемость** — возможность unit-тестировать действия изолированно от UI
- **Унифицировать паттерн** — использовать одинаковый подход в `GalleryPage.tsx` и `DashboardPage.tsx`

---

## 2. Ключевые архитектурные проблемы

| Проблема | Влияние |
|----------|---------|
| Монолитный `handleConfirmAction` с `TODO THIS IS VERY BAD` | Нарушение OCP, при добавлении действий растёт цикломатическая сложность |
| `data?: unknown` в state | Потеря типизации, runtime-ошибки при неверных приведениях |
| Состояние модала внутри page-компонента | Невозможно переиспользовать между страницами или вызвать из сервисов |
| Дублирование — DashboardPage использует inline-модалы | Несогласованный UX и код |
| Error handling разделён | Модал логирует ошибку, родитель показывает через отдельный `setError` |

---

## 3. Направления рефакторинга

### Вариант A: Callback-first (минимальные изменения)
- Вместо `type` передавать готовый `onConfirm: () => Promise<void>` прямо в момент открытия модала
- Убирает switch полностью — каждый вызов сам определяет, что делать
- **Trade-off**: логика остаётся размазана по компоненту, но избавляемся от маппинга типов

### Вариант B: Custom hook `useConfirmation()`
- Создать хук по образцу существующего `useAsyncHandler` из `useErrorHandler.ts`
- Хук возвращает `{ confirm, modal }` — `confirm(options)` открывает модал и возвращает Promise
- Компонент рендерит только `{modal}`, вся логика инкапсулирована
- **Trade-off**: требует render-prop или portal-паттерн для размещения JSX

### Вариант C: Zustand store `useConfirmationStore`
- Глобальный store (по образцу `authStore.ts`)
- Методы: `openConfirmation({ title, message, onConfirm, ...options })`
- Один `<ConfirmationModalProvider>` в `Layout.tsx`
- **Trade-off**: глобальное состояние для UI-элемента; нужно следить за cleanup

### Вариант D: Action Registry + Strategy Pattern
- Типизированный реестр действий: `const actions: Record<ActionType, ActionHandler<TData>>`
- Каждое действие — отдельный модуль с типизированным payload
- Dispatcher находит handler по типу и вызывает его
- **Trade-off**: over-engineering для 4-5 действий, но отлично масштабируется

---

## 4. Критерии хорошего решения

| Критерий | Описание |
|----------|----------|
| **Типобезопасность** | Полная типизация payload, без `unknown` и приведений |
| **Расширяемость** | Добавление действия = новый файл/функция, без изменения core |
| **Тестируемость** | Action-логику можно протестировать без рендера модала |
| **Единообразие** | Один паттерн для всех страниц и сценариев |
| **Минимум boilerplate** | Открытие модала — 1-2 строки кода |
| **Переиспользуемость** | `ConfirmationModal.tsx` остаётся «чистым» презентационным компонентом |

---

## 5. Потенциальные риски и trade-offs

| Риск | Митигация |
|------|-----------|
| Глобальный store для UI (вариант C) — усложняет SSR/тестирование | Можно ограничить контекстом Layout без persist |
| Over-engineering (вариант D) для текущего масштаба | Начать с варианта A или B, мигрировать позже при росте |
| Потеря контроля над loading/error state | Хук/store должен возвращать Promise и пробрасывать ошибки вызывающему коду |
| Миграционные затраты — 2 страницы + тесты | Инкрементальный подход: сначала hook, потом рефакторинг страниц |
| Несовместимость с существующими e2e-тестами | Сохранить data-testid и aria-атрибуты |

---

## 6. Рекомендация

**Оптимальный путь: Вариант B (custom hook) + элементы Вариант A (callback)**

1. Создать `useConfirmation()` хук возвращающий `{ openConfirm, ConfirmModal }`
2. `openConfirm({ title, message, onConfirm, isDangerous })` — императивный вызов
3. `onConfirm` передаётся как callback с уже захваченным контекстом (photoId, galleryId)
4. Типизировать options через generics если нужен payload
5. Разместить `<ConfirmModal />` внутри Layout или локально в page

**Почему**: минимальный объём изменений, использует существующие паттерны кодовой базы (hooks), полностью устраняет switch, сохраняет локальность состояния.

---

## Дальнейшие шаги (для обсуждения)

1. Согласовать направление (A/B/C/D) с командой
2. Определить, нужен ли глобальный confirmation (Zustand) или достаточно per-page хука
3. Приоритизировать унификацию DashboardPage или оставить на потом
4. Решить вопрос с non-destructive confirmations (isDangerous=false) — нужны ли они
